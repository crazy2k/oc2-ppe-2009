#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\date{}
\setcounter{page}{-1}
\end_preamble
\use_default_options false
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title

\series bold
\shape smallcaps
Organización del Computador II
\end_layout

\begin_layout Standard
\align center

\shape italic
\size large
Departamento de Computación,
\begin_inset Newline newline
\end_inset

 Facultad de Ciencias Exactas y Naturales,
\begin_inset Newline newline
\end_inset

Universidad de Buenos Aires
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\shape smallcaps
\size larger
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features>
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align center

\series bold
\shape smallcaps
\size larger
Trabajo Práctico 1: “Oportuncrisis”
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\shape italic
Primer Cuatrimestre de 2009
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Grupo "UNPCKHPD"
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row topspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pablo Antonio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
290/08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pabloa@gmail.com
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pablo Herrero
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
332/07
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pablodherrero@gmail.com
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estefanía Porta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
451/04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
estef.barbara@gmail.com
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
El trabajo práctico consiste en programar, en lenguaje 
\emph on
assembly
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Se optó por el ensamblador NASM, y se escribió el código en el lenguaje
 que este soporta.
\end_layout

\end_inset

 de la 
\emph on
arquitectura x86 de Intel
\emph default
, ciertas funciones de un videojuego.
 La lógica del videojuego se halla programada en C/C++, y utiliza un número
 de funciones que, en principio, no se encuentran implementadas.
 Nuestra tarea fue implementar dichas funciones.
\end_layout

\begin_layout Standard
Las funciones faltantas se encargan de implementar:
\end_layout

\begin_layout Itemize
las funcionalidades básicas de una 
\emph on
lista doblemente enlazada
\end_layout

\begin_layout Itemize
las funcionalidades de un 
\emph on
iterador
\emph default
 que sirva para recorrer dicha lista
\end_layout

\begin_layout Itemize
una función 
\family typewriter
recortar
\family default
, encargada de, a partir de un 
\emph on
sprite
\emph default
 que contiene varias instancias de un objeto visual, y dados los parámetros
 necesarios, quedarse con una instancia de este, y depositarla en un lugar
 específico con la orientación adecuada
\end_layout

\begin_layout Itemize
una función 
\family typewriter
blit 
\family default
que deberá, dada una imagen con un fondo de un color dado (el 
\emph on
color-off
\emph default
) y otra imagen, reemplazar en la primera los pixeles de dicho color por
 los pixeles correspondientes en la segunda imagen, a partir de un par de
 coordenadas especificado
\end_layout

\begin_layout Itemize
una función 
\family typewriter
generarFondo
\family default
, capaz de, a partir de una imagen para el fondo y una coordenada 
\begin_inset Formula $x$
\end_inset

 en este, dibujarlo en pantalla tomando como inicio del fondo la coordenada
 especificada.
 De no contar con suficiente ancho en el fondo a partir de dicha coordenada
 como para llenar el ancho de la pantalla por completo, deberá tomar como
 valor de dicha coordenada, el valor máximo suficiente que permita llenar
 la pantalla.
\end_layout

\begin_layout Itemize
una función 
\family typewriter
generarPlasma
\family default
, encargada de crear un efecto visual llamado 
\begin_inset Quotes eld
\end_inset

plasma
\begin_inset Quotes erd
\end_inset

, y de reemplazar en la pantalla ciertos pixeles de un color, por los correspond
ientes a este efecto
\end_layout

\begin_layout Standard
Se utilizaron, a lo largo del trabajo, 
\emph on
bitmaps
\emph default
 de 24 bits de color.
 Tanto la pantalla como las imágenes cargadas se recorrieron como una matriz
 de pixeles, donde cada pixel estaba representado por tres bytes, uno para
 cada componente RGB del color a mostrar.
\end_layout

\begin_layout Standard
El juego hace uso de la 
\emph on
biblioteca multiplataforma libre SDL
\emph default
.
\end_layout

\begin_layout Subsection
¿Qué se muestra por pantalla?
\end_layout

\begin_layout Standard
Muy básicamente, el juego consta de un ciclo que se repite todo el tiempo:
\end_layout

\begin_layout Verse
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

procesar eventos de entrada
\end_layout

\begin_layout Plain Layout

actualizar posiciones, estados, etc.
\end_layout

\begin_layout Plain Layout

chequear IA, colisiones, física, etc.
\end_layout

\begin_layout Plain Layout

mostrar resultados por pantalla
\end_layout

\begin_layout Plain Layout

ira a 1.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la etapa 4 (
\begin_inset Quotes eld
\end_inset

mostrar resultados por pantalla
\begin_inset Quotes erd
\end_inset

), que es la que nos atañe en este trabajo, la secuencia que se sigue es
 la siguiente:
\end_layout

\begin_layout Verse
\begin_inset listings
lstparams "breaklines=true,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

generar el fondo actual (generarFondo)
\end_layout

\begin_layout Plain Layout

generar el plasma, usando como color-off el color del cielo del fondo (generarPl
asma)
\end_layout

\begin_layout Plain Layout

para cada sprite de cada personaje:
\end_layout

\begin_layout Plain Layout

	recortar la instancia que se quiere del personaje
\end_layout

\begin_layout Plain Layout

	aplicar blit (cambiar el color-off del personaje por lo que haya en la
 pantalla)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tener este esquema en mente nos ayudará a entender mejor las explicaciones
 que vienen a continuación.
 A su vez, las explicaciones que vienen a continuación, completarán y darán
 sentido al esquema.
\end_layout

\begin_layout Subsection
Los 
\emph on
sprites
\end_layout

\begin_layout Standard
Un 
\emph on
sprite
\emph default
, para nosotros,
\emph on
 
\emph default
es una imagen compuesta por una tira de figuras que se utilizan para dar
 movimiento a los personajes.
 En nuestro caso, tenemos un sprite para cada una de las animaciones de
 los movimientos de Wolverine (parado, caminando y atacando) y Gambit (parado).
\end_layout

\begin_layout Standard
Para simular el movimiento de los personajes, se muestran por pantalla una
 a una las figuras de la tira, en la misma posición (o con algún desplazamiento
 si se quiere mostrar que el personaje se traslada).
 El usuario observa un movimiento por parte de los personajes pues el ojo
 humano no alcanza a percibir que en realidad se trata de varias figuras
 una detrás de la otra.
\end_layout

\begin_layout Subsection
Los fondos
\end_layout

\begin_layout Standard
En nuestro juego, tenemos dos fondos; uno para cada escenario.
 Los fondos tienen un cierto ancho, en nuestro caso mayor al de la pantalla.
 Inicialmente se muestra en la pantalla la primera parte del fondo (observándolo
 de izquierda a derecha).
 A medida que el personaje avanza hacia un lado u otro de la pantalla nuevas
 porciones del fondo se hacen visibles, generando la sensación de que el
 personaje está recorriéndolo.
\end_layout

\begin_layout Subsection
El 
\emph on
color-off
\end_layout

\begin_layout Standard
Siendo bitmaps, lógicamente las imágenes de los personajes y las de los
 fondos tienen un color asignado a cada pixel que los conforma.
 Sin embargo, para que el movimiento del personaje a través del escenario
 sea más realista, preferiríamos que ciertas zonas de su bitmap no se mantengan
 estáticas, sino que vayan cambiando conforme al contexto que lo rodea en
 cada momento.
 Además, también puede sernos útil que el mismo fondo se comporte de manera
 similar; por ejemplo, podríamos querer que en cierta parte del fondo designada
 al cielo las nubes vayan moviéndose, en lugar de que se mantenga estática.
\end_layout

\begin_layout Standard
Para lograr esto se elige un color en el bitmap al cual se lo llama 
\begin_inset Quotes eld
\end_inset

color-off
\begin_inset Quotes erd
\end_inset

.
 Simplemente se trata de un color RGB que no será utilizado en el bitmap
 sino para designar pixeles que serán reemplazados por otros.
 En el caso del personaje, estos pixeles podrán reemplazarse por pixeles
 correspondientes al fondo.
\end_layout

\begin_layout Subsection
El 
\emph on
plasma
\end_layout

\begin_layout Standard
Para colaborar con la ambientación de las escenas, se utilizó un fondo de
 
\emph on
plasma
\emph default
.
 Básicamente, se trata de una imagen que se genera a partir de una función
 senoidal y ciertas designaciones de colores a los puntos.
 El efecto resultante podría describirse como una serie de círculos y circunfere
ncias de distintos colores (en nuestro caso, mayormente verde azul y negro)
 agrandándose, achicándose y trasladándose a lo largo de la pantalla.
\end_layout

\begin_layout Subsection
La lista y el iterador
\end_layout

\begin_layout Standard
Para disponer de personajes estáticos (que no se trasladan) en la escena
 que, a su vez, pueden desaparecer de ella (por ejemplo, al ser atacados
 por nuestro personaje principal), puede disponerse de una lista que los
 contenga, de manera que pueda eliminárselos de ella en caso de necesitarlo.
\end_layout

\begin_layout Standard
Para recorrerla con facilidad, se construyó también un iterador muy simple
 que permite atravaserla.
\end_layout

\begin_layout Section
Desarrollo
\end_layout

\begin_layout Subsection
Funciones desarrolladas
\end_layout

\begin_layout Subsubsection
Función 
\family typewriter
recortar
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
void recortar(Uint8* sprite, Uint32 instancia, Uint32 ancho_instancia, Uint32
 ancho_sprite, Uint32 alto_sprite, Uint8* res, bool orientacion);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Parámetros:
\end_layout

\begin_layout Itemize

\family typewriter
sprite
\family default
 es un puntero a la imagen que contiene el sprite
\end_layout

\begin_layout Itemize

\family typewriter
instancia
\family default
 es el número correspondiente a la figura que se quiere obtener recortando
 del sprite
\end_layout

\begin_layout Itemize

\family typewriter
ancho_instancia
\family default
 es el ancho de cada una de las instancias (figuras) en el sprite (asumimos
 que todas las instancias tienen un mismo ancho)
\end_layout

\begin_layout Itemize

\family typewriter
ancho_sprite
\family default
 es el ancho de la imagen del sprite
\end_layout

\begin_layout Itemize

\family typewriter
alto_sprite
\family default
 es la altura de la imagen del sprite
\end_layout

\begin_layout Itemize

\family typewriter
res
\family default
 es un puntero a un espacio en memoria reservado para depositar la imagen
 recortada
\end_layout

\begin_layout Itemize

\family typewriter
orientacion
\family default
 indica la orientación que tendrá la imagen recortada (si el valor de orientació
n así lo indica, la figura recortada se mostrará orientada hacia el lado
 contrario al que aparece en el sprite)
\end_layout

\begin_layout Subsubsection
Función 
\family typewriter
blit
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
void blit(Uint8 *image, Uint32 w, Uint32 h, Uint32 x, Uint32 y, Color rgb);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Parámetros:
\end_layout

\begin_layout Itemize

\family typewriter
image
\family default
 es un puntero a la imagen que se desea tratar
\end_layout

\begin_layout Itemize

\family typewriter
w
\family default
 es el ancho de la imagen
\end_layout

\begin_layout Itemize

\family typewriter
h
\family default
 es la altura de la imagen
\end_layout

\begin_layout Itemize

\family typewriter
x
\family default
 e 
\family typewriter
y
\family default
 son las coordenadas de la posición en la pantalla a partir de la cual se
 obtendrán los datos para reemplazar en la imagen
\end_layout

\begin_layout Itemize

\family typewriter
rgb
\family default
 representa al color-off, es decir, el color en el que están pintados en
 la imagen los pixeles a ser reemplazados
\end_layout

\begin_layout Subsubsection
Función 
\family typewriter
generarFondo
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
void generarFondo (Uint8 *fondo, Uint32 fondo_w, Uint32 fondo_h, Uint32
 screenAbsPos);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Parámetros:
\end_layout

\begin_layout Itemize

\family typewriter
fondo
\family default
 es un puntero al lugar en el que se encuentra el fondo cargado en memoria
\end_layout

\begin_layout Itemize

\family typewriter
fondo_w
\family default
 es el ancho de la imagen del fondo
\end_layout

\begin_layout Itemize

\family typewriter
fondo_h
\family default
 es la altura de la imagen del fondo
\end_layout

\begin_layout Itemize

\family typewriter
screenAbsPos
\family default
 es la posición en 
\begin_inset Formula $X$
\end_inset

 del fondo a partir de la cual se quiere comenzar a dibujar
\end_layout

\begin_layout Subsubsection
Función 
\family typewriter
generarPlasma
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
void generarPlasma(Color rgb)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Parámetros:
\end_layout

\begin_layout Itemize

\family typewriter
rgb
\family default
 es el color del que estarán pintados los pixeles que serán reemplazados
 por el efecto de plasma
\end_layout

\begin_layout Subsubsection
Lista
\end_layout

\begin_layout Standard
La lista consta de dos estructuras muy simples:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

struct Nodo {
\end_layout

\begin_layout Plain Layout

	Uint64  ID;
\end_layout

\begin_layout Plain Layout

	SDL_Surface *surfaceGen;
\end_layout

\begin_layout Plain Layout

	SDL_Surface *surfacePers;
\end_layout

\begin_layout Plain Layout

	Uint32 coord_x;
\end_layout

\begin_layout Plain Layout

	Uint32 coord_y;
\end_layout

\begin_layout Plain Layout

	Nodo* prox;
\end_layout

\begin_layout Plain Layout

	Nodo* prev;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

struct Lista {
\end_layout

\begin_layout Plain Layout

	Nodo* primero;
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La idea es que las variables del tipo 
\family typewriter
Lista
\family default
 sólo contengan un puntero al primer elemento de la lista.
 Los nodos se encuentran doblemente enlazados (cada nodo tiene una referencia
 al nodo previo y al nodo próximo).
 El puntero al nodo previo del primer elemento debe apuntar a 
\family typewriter
NULL
\family default
, lo mismo que el puntero al próximo del último.
\end_layout

\begin_layout Standard
Se pedían las siguientes funciones:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

Lista* constructor_lista();
\end_layout

\begin_layout Plain Layout

void inicializar_nodo(Nodo* nuevo, SDL_Surface *surfacePers, SDL_Surface
 *surfaceGen, Uint32 x, Uint32 y, Uint32 ID);
\end_layout

\begin_layout Plain Layout

bool verificar_id (Lista* la_lista, Uint32 id);
\end_layout

\begin_layout Plain Layout

void agregar_item_ordenado(Lista* la_lista, SDL_Surface* surfacePers, SDL_Surfac
e* surfaceGen, Uint32 x, Uint32 y, Uint32 ID);
\end_layout

\begin_layout Plain Layout

void borrar(Lista* la_lista, Uint32 x, Uint32 y);
\end_layout

\begin_layout Plain Layout

void liberar_lista(Lista* l); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las construimos a todas, con la excepción de 
\family typewriter
inicializar_nodo
\family default
 que era opcional.
 Pudimos haberla usado en la función 
\family typewriter
agregar_item_ordenado
\family default
, pero decidimos no hacerlo; nos pareció que agregaría un 
\emph on
overhead
\emph default
 innecesario.
\end_layout

\begin_layout Standard
Todas las funciones que atañen a la lista se encuentran en el mismo archivo,
 
\family typewriter
funciones_lista.asm
\family default
.
\end_layout

\begin_layout Subsubsection
Iterador
\end_layout

\begin_layout Standard
La estructura del iterador es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct Iterador {
\end_layout

\begin_layout Plain Layout

	Nodo *actual;
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La idea es que el puntero del iterador se encuentre siempre apuntando a
 un nodo (el nodo actual) de la lista que recorre.
 A continuación, las funciones correspondientes al iterador pedidas:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true"
inline false
status open

\begin_layout Plain Layout

Iterador *iterador_lista;
\end_layout

\begin_layout Plain Layout

Iterador* constructor_iterador(Lista *lista);
\end_layout

\begin_layout Plain Layout

void proximo(Iterador *iter);
\end_layout

\begin_layout Plain Layout

Nodo* item(Iterador *iter);
\end_layout

\begin_layout Plain Layout

bool hay_proximo(Iterador *iter);
\end_layout

\begin_layout Plain Layout

void liberar_iterador(Iterador *iter); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Todas estas funciones se hallan en el archivo 
\family typewriter
funciones_iterador.asm
\family default
.
\end_layout

\begin_layout Subsection
Basura en los bitmaps
\end_layout

\begin_layout Standard
El formato de los bitmaps que utilizamos alineaba cada fila de pixeles a
 un múltiplo de 32 bits.
 Esto quiere decir que, cuando la fila de pixeles no ocupaba un múltiplo
 de 32 bits, el bitmap contenía, luego de los datos correspondientes a los
 colores de los pixeles, datos 
\begin_inset Quotes eld
\end_inset

basura
\begin_inset Quotes erd
\end_inset

 para llevar la fila a un múltiplo de 32 bits.
\end_layout

\begin_layout Standard
En cada una de las funciones que se ocupaban de leer o bien de escribir
 en los bitmaps cargados en memoria, tuvimos que tener en cuenta esto.
 Como el direccionamiento en la arquitectura que utilizamos es a byte, tuvimos
 que prestar atención al hecho de que cada fila de pixeles tendría que empezar
 en una dirección múltiplo de 4.
\end_layout

\begin_layout Subsection
Manejo de la pila (
\family typewriter
entrada_funcion
\family default
 y 
\family typewriter
salida_funcion
\family default
)
\end_layout

\begin_layout Standard
Al arribar a la función, en la pila (
\emph on
stack
\emph default
) se encuentran los parámetros pasados y, a continuación y en el tope, la
 dirección de retorno a la cual deberá volverse luego de la ejecución de
 la función.
 Ese es el momento en el cual debe armarse el 
\family typewriter
stack frame
\family default
 de la función.
 Para hacerlo, precisamos lo siguiente:
\end_layout

\begin_layout Enumerate
mover el puntero a la base de la pila (
\family typewriter
ebp
\family default
) al tope de esta
\end_layout

\begin_layout Enumerate
de ser necesario, puede reservarse espacio en la pila para almacenar variables/d
atos locales (es decir, que sólo interesan a la función); para esto, sólo
 basta decrementar el puntero al tope de la pila tantas veces como palabras
 de 32 bits se quieran reservar
\end_layout

\begin_layout Standard
Además, como la convención C asegura que los registros 
\family typewriter
edi
\family default
, 
\family typewriter
esi
\family default
 y 
\family typewriter
ebx
\family default
 deben mantenerse en sus valores iniciales al momento del retorno, es una
 práctica común (que también adoptamos) enviarlos al tope de la pila.
\end_layout

\begin_layout Standard
Como debíamos realizar esta tarea en la gran mayoría de las funciones, nos
 fue útil construirnos una macro 
\family typewriter
entrada_funcion
\family default
 y su contrapartida 
\family typewriter
salida_funcion
\family default
, encargadas de realizar las tareas mencionadas (la primera) y de dejar
 el stack en el estado inicial (la segunda).
\end_layout

\begin_layout Standard
A continuación el código correspondiente a las macros mencionadas:
\end_layout

\begin_layout Standard
Dado que, como mencionamos, la mayoría de las funciones recibían parámetros,
 nos fue útil la creación de una macro llamada 
\family typewriter
entrada_funcion 
\family default
y su contrapartida
\family typewriter
 salida_funcion
\family default
.
 A continuación, las macros mencionadas:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%macro entrada_funcion 1
\end_layout

\begin_layout Plain Layout

	push ebp
\end_layout

\begin_layout Plain Layout

	mov ebp, esp
\end_layout

\begin_layout Plain Layout

	%if %1 <> 0
\end_layout

\begin_layout Plain Layout

	sub esp, %1
\end_layout

\begin_layout Plain Layout

	%endif
\end_layout

\begin_layout Plain Layout

	push edi
\end_layout

\begin_layout Plain Layout

	push esi
\end_layout

\begin_layout Plain Layout

	push ebx
\end_layout

\begin_layout Plain Layout

%endmacro
\end_layout

\begin_layout Plain Layout

%macro salida_funcion 1
\end_layout

\begin_layout Plain Layout

	pop ebx
\end_layout

\begin_layout Plain Layout

	pop esi
\end_layout

\begin_layout Plain Layout

	pop edi
\end_layout

\begin_layout Plain Layout

	%if %1 <> 0
\end_layout

\begin_layout Plain Layout

	add esp, %1
\end_layout

\begin_layout Plain Layout

	%endif
\end_layout

\begin_layout Plain Layout

	pop ebp
\end_layout

\begin_layout Plain Layout

    ret
\end_layout

\begin_layout Plain Layout

%endmacro 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Recepción de parámetros
\end_layout

\begin_layout Standard
La mayoría de las funciones que tuvimos que construir recibían parámetros.
 Estos parámetros, en su mayoría, eran pasados a través de la pila.
 Como las funciones eran utilizadas desde C/C++, debió seguirse la convención
 de C para el pasaje (y la recepción) de parámetros.
 Dicha convención dice que los parámetros que recibirá la función se introducen
 en la pila uno a uno, desde el último al primero, es decir, de derecha
 a izquierda.
\end_layout

\begin_layout Standard
Para mejorar la legibilidad de nuestro código, en todas las funciones que
 recibían parámetros, definimos algunas constantes con nombres declarativos
 para cada uno de los parámetros, los cuales referenciamos usando la base
 de la pila (
\family typewriter
ebp
\family default
).
\end_layout

\begin_layout Standard
Por ejemplo, para el caso de la función 
\family typewriter
generarFondo
\family default
, cuya firma era
\end_layout

\begin_layout Standard

\family typewriter
void generarFondo (Uint8 *fondo, Uint32 fondo_w, Uint32 fondo_h, Uint32
 screenAbsPos);
\end_layout

\begin_layout Standard
definimos las siguientes constantes:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[x86masm]Assembler}"
inline false
status open

\begin_layout Plain Layout

%define fondo [ebp + 8]
\end_layout

\begin_layout Plain Layout

%define fondo_w [ebp + 12]
\end_layout

\begin_layout Plain Layout

%define fondo_h [ebp + 16]
\end_layout

\begin_layout Plain Layout

%define coord [ebp + 20] 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Reserva y liberación de memoria (
\family typewriter
malloc
\family default
 y 
\family typewriter
free
\family default
)
\end_layout

\begin_layout Standard
En algunas funciones, como es el caso de los constructores (y destructores)
 del iterador y de la lista, teníamos que reservar (y liberar) memoria en
 el 
\emph on
heap
\emph default
.
 Para esto, utilizamos las funciones de C 
\family typewriter
malloc
\family default
 y 
\family typewriter
free
\family default
.
\end_layout

\begin_layout Standard
Siguiendo la convención de C, pasamos los parámetros a estas funciones a
 través de la pila.
 En el caso de 
\family typewriter
malloc
\family default
 tuvimos que pasar el número de bytes a reservar, y en el caso de 
\family typewriter
free
\family default
 la dirección de memoria del espacio a liberar.
\end_layout

\begin_layout Standard
Ambas funciones, también siguiendo la convención de C, retornaban valores
 a través del registro 
\family typewriter
eax
\family default
.
 
\family typewriter
malloc
\family default
 retornaba la dirección de memoria en la cual se ubicaba el espacio reservado
 (o cero, en el caso de no haber podido reservar memoria) y 
\family typewriter
free
\family default
 retornaba si la liberación había sido exitosa.
\end_layout

\begin_layout Subsection
Acceso a variables globales
\end_layout

\begin_layout Standard
Algunas de nuestras funciones requerían acceder a variables globales (como,
 por ejemplo, la matriz de pixeles correspondiente a la pantalla), declaradas
 en el programa en C++.
 Para acceder a dichas variables, no hizo falta más que utilizar 
\family typewriter
extern variable
\family default
 (siendo 
\family typewriter
variable
\family default
 una variable global) en alguna parte de nuestros archivos de assembly.
\end_layout

\begin_layout Standard
El símbolo 
\family typewriter
variable
\family default
 debió utilizarse luego como una dirección de memoria: la dirección que
 apunta a la variable.
 En otras palabras, utilizando 
\family typewriter
extern
\family default
 contábamos con un puntero a la variable en memoria.
\end_layout

\begin_layout Section
Resultados
\end_layout

\begin_layout Subsection

\emph on
Debugging
\end_layout

\begin_layout Standard
Los programas enfocados al 
\emph on
debugging
\emph default
 son herramientas muy importantes, especialmente para el programador de
 lenguajes de bajo nivel.
 En nuestro caso, nos sirvieron para encontrar errores en nuestro código
 y entender por qué al principio muchas de nuestras funciones no arrojaban
 los resultados esperados.
\end_layout

\begin_layout Standard
Los programas que más nos ayudaron en esta tarea fueron:
\end_layout

\begin_layout Itemize
gdb (y sus frontends: ddd, Nemiver)
\end_layout

\begin_layout Itemize
valgrind
\end_layout

\begin_layout Subsection
El problema de la basura en los bitmaps
\end_layout

\begin_layout Standard
En un principio, no sabíamos con certidumbre cómo era el formato de bitmaps
 con el que estábamos trabajando.
 No todos los formatos de bitmaps son alineados a 32 bits, como este.
\end_layout

\begin_layout Standard
Al realizar las funciones sin pensar siquiera en la basura, encontrábamos
 resultados extraños: en 
\family typewriter
generarFondo
\family default
, por ejemplo, obteníamos imágenes torcidas/inclinadas.
\end_layout

\begin_layout Standard
Este fue un problema en el cual el 
\emph on
debugger
\emph default
 poco podía hacer: la cantidad de datos, en este caso los pixeles de las
 imágenes, era muy extensa y variada, y además analizar un mapa de la memoria
 no es tan fácil como observar el cambio de los valores de los registros.
\end_layout

\begin_layout Section
Conclusiones
\end_layout

\begin_layout Standard
A partir de la realización de este trabajo práctico sacamos varias conclusiones:
\end_layout

\begin_layout Itemize
Escribir funciones que parecen muy simples y fáciles de construir en un
 lenguaje de alto nivel, puede tornarse una 
\emph on
tarea muy compleja
\emph default
 en un lenguaje de bajo nivel como el que manejamos.
\end_layout

\begin_layout Itemize
Por fortuna, existen herramientas para facilitarnos las cosas, como los
 
\emph on
debuggers
\emph default
.
\end_layout

\begin_layout Itemize
Escribir en 
\emph on
assembly
\emph default
, si bien es una tarea ardua, resultó ser provechoso, pues nos posibilitó
 entender qué es lo que se esconde detrás de los lenguajes de alto nivel,
 de sus abstracciones para el manejo fácil de memoria, de sus sistemas de
 tipos.
\end_layout

\begin_layout Section*
Referencias
\end_layout

\begin_layout Itemize
Intel R .
 64 and IA-32 Architectures Software 1: Basic Architecture
\end_layout

\begin_layout Itemize
Intel R.
 64 and IA-32 Architectures Software 2A: Instruction Set Reference, A-M
\end_layout

\begin_layout Itemize
Intel R.
 64 and IA-32 Architectures Software 2B: Instruction Set Reference, N-Z
\end_layout

\begin_layout Itemize
Información sobre bitmaps: http://en.wikipedia.org/wiki/BMP_file_format
\end_layout

\begin_layout Itemize
Documentación del NASM: http://www.nasm.us/doc/ 
\end_layout

\end_body
\end_document
